schema {
  query: query_root
  subscription: subscription_root
}

scalar bundesland

# expression to compare columns of type bundesland. All fields are combined with logical 'AND'.
input bundesland_comparison_exp {
  _eq: bundesland
  _gt: bundesland
  _gte: bundesland
  _in: [bundesland!]
  _is_null: Boolean
  _lt: bundesland
  _lte: bundesland
  _neq: bundesland
  _nin: [bundesland!]
}

scalar date

# expression to compare columns of type date. All fields are combined with logical 'AND'.
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# columns and relationships of "lehrplan"
type lehrplan {
  bundesland: bundesland!
  fach: String!
  klassenstufe: Int!

  # An object relationship
  lehrplandetail: lehrplandetails!
  lehrplanid: Int!
  schulart_intern: String!
}

# Boolean expression to filter rows from the table "lehrplan". All fields are combined with a logical 'AND'.
input lehrplan_bool_exp {
  _and: [lehrplan_bool_exp]
  _not: lehrplan_bool_exp
  _or: [lehrplan_bool_exp]
  bundesland: bundesland_comparison_exp
  fach: String_comparison_exp
  klassenstufe: Int_comparison_exp
  lehrplandetail: lehrplandetails_bool_exp
  lehrplanid: Int_comparison_exp
  schulart_intern: String_comparison_exp
}

# ordering options when selecting data from "lehrplan"
input lehrplan_order_by {
  bundesland: order_by
  fach: order_by
  klassenstufe: order_by
  lehrplandetail: lehrplandetails_order_by
  lehrplanid: order_by
  schulart_intern: order_by
}

# select columns of table "lehrplan"
enum lehrplan_select_column {
  # column name
  bundesland

  # column name
  fach

  # column name
  klassenstufe

  # column name
  lehrplanid

  # column name
  schulart_intern
}

# columns and relationships of "lehrplandetails"
type lehrplandetails {
  beschreibung: String
  eintragsdatum: date!
  elternid: Int
  hierarchie: String

  # An object relationship
  lehrplandetail: lehrplandetails

  # An array relationship
  lehrplandetails(
    # distinct select on columns
    distinct_on: [lehrplandetails_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplandetails_order_by!]

    # filter the rows returned
    where: lehrplandetails_bool_exp
  ): [lehrplandetails!]!
  lehrplanid: Int!

  # An array relationship
  lehrplans(
    # distinct select on columns
    distinct_on: [lehrplan_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplan_order_by!]

    # filter the rows returned
    where: lehrplan_bool_exp
  ): [lehrplan!]!

  # An array relationship
  lehrplanzuordnungs(
    # distinct select on columns
    distinct_on: [lehrplanzuordnung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplanzuordnung_order_by!]

    # filter the rows returned
    where: lehrplanzuordnung_bool_exp
  ): [lehrplanzuordnung!]!
  quelle: String!
  titel: String
}

# Boolean expression to filter rows from the table "lehrplandetails". All fields are combined with a logical 'AND'.
input lehrplandetails_bool_exp {
  _and: [lehrplandetails_bool_exp]
  _not: lehrplandetails_bool_exp
  _or: [lehrplandetails_bool_exp]
  beschreibung: String_comparison_exp
  eintragsdatum: date_comparison_exp
  elternid: Int_comparison_exp
  hierarchie: String_comparison_exp
  lehrplandetail: lehrplandetails_bool_exp
  lehrplandetails: lehrplandetails_bool_exp
  lehrplanid: Int_comparison_exp
  lehrplans: lehrplan_bool_exp
  lehrplanzuordnungs: lehrplanzuordnung_bool_exp
  quelle: String_comparison_exp
  titel: String_comparison_exp
}

# ordering options when selecting data from "lehrplandetails"
input lehrplandetails_order_by {
  beschreibung: order_by
  eintragsdatum: order_by
  elternid: order_by
  hierarchie: order_by
  lehrplandetail: lehrplandetails_order_by
  lehrplanid: order_by
  quelle: order_by
  titel: order_by
}

# select columns of table "lehrplandetails"
enum lehrplandetails_select_column {
  # column name
  beschreibung

  # column name
  eintragsdatum

  # column name
  elternid

  # column name
  hierarchie

  # column name
  lehrplanid

  # column name
  quelle

  # column name
  titel
}

# columns and relationships of "lehrplanzuordnung"
type lehrplanzuordnung {
  # An object relationship
  lehrplandetail: lehrplandetails!
  lehrplanid: Int!
  modul: String!

  # An object relationship
  module: module!
}

# Boolean expression to filter rows from the table "lehrplanzuordnung". All fields are combined with a logical 'AND'.
input lehrplanzuordnung_bool_exp {
  _and: [lehrplanzuordnung_bool_exp]
  _not: lehrplanzuordnung_bool_exp
  _or: [lehrplanzuordnung_bool_exp]
  lehrplandetail: lehrplandetails_bool_exp
  lehrplanid: Int_comparison_exp
  modul: String_comparison_exp
  module: module_bool_exp
}

# ordering options when selecting data from "lehrplanzuordnung"
input lehrplanzuordnung_order_by {
  lehrplandetail: lehrplandetails_order_by
  lehrplanid: order_by
  modul: order_by
  module: module_order_by
}

# select columns of table "lehrplanzuordnung"
enum lehrplanzuordnung_select_column {
  # column name
  lehrplanid

  # column name
  modul
}

# columns and relationships of "material"
type material {
  downvotes: Int!
  link: String!
  materialart: ressourcenart!
  materialbeschreibung: String
  materialeintragsdatum: date!
  materialtestdatum: date
  materialtitel: String!

  # An array relationship
  materialzuordnungs(
    # distinct select on columns
    distinct_on: [materialzuordnung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materialzuordnung_order_by!]

    # filter the rows returned
    where: materialzuordnung_bool_exp
  ): [materialzuordnung!]!
  upvotes: Int!
}

# Boolean expression to filter rows from the table "material". All fields are combined with a logical 'AND'.
input material_bool_exp {
  _and: [material_bool_exp]
  _not: material_bool_exp
  _or: [material_bool_exp]
  downvotes: Int_comparison_exp
  link: String_comparison_exp
  materialart: ressourcenart_comparison_exp
  materialbeschreibung: String_comparison_exp
  materialeintragsdatum: date_comparison_exp
  materialtestdatum: date_comparison_exp
  materialtitel: String_comparison_exp
  materialzuordnungs: materialzuordnung_bool_exp
  upvotes: Int_comparison_exp
}

# ordering options when selecting data from "material"
input material_order_by {
  downvotes: order_by
  link: order_by
  materialart: order_by
  materialbeschreibung: order_by
  materialeintragsdatum: order_by
  materialtestdatum: order_by
  materialtitel: order_by
  upvotes: order_by
}

# select columns of table "material"
enum material_select_column {
  # column name
  downvotes

  # column name
  link

  # column name
  materialart

  # column name
  materialbeschreibung

  # column name
  materialeintragsdatum

  # column name
  materialtestdatum

  # column name
  materialtitel

  # column name
  upvotes
}

# columns and relationships of "materialzuordnung"
type materialzuordnung {
  link: String!

  # An object relationship
  material: material!
  modul: String!

  # An object relationship
  module: module!
}

# Boolean expression to filter rows from the table "materialzuordnung". All fields are combined with a logical 'AND'.
input materialzuordnung_bool_exp {
  _and: [materialzuordnung_bool_exp]
  _not: materialzuordnung_bool_exp
  _or: [materialzuordnung_bool_exp]
  link: String_comparison_exp
  material: material_bool_exp
  modul: String_comparison_exp
  module: module_bool_exp
}

# ordering options when selecting data from "materialzuordnung"
input materialzuordnung_order_by {
  link: order_by
  material: material_order_by
  modul: order_by
  module: module_order_by
}

# select columns of table "materialzuordnung"
enum materialzuordnung_select_column {
  # column name
  link

  # column name
  modul
}

# columns and relationships of "module"
type module {
  # An array relationship
  lehrplanzuordnungs(
    # distinct select on columns
    distinct_on: [lehrplanzuordnung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplanzuordnung_order_by!]

    # filter the rows returned
    where: lehrplanzuordnung_bool_exp
  ): [lehrplanzuordnung!]!

  # An array relationship
  materialzuordnungs(
    # distinct select on columns
    distinct_on: [materialzuordnung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materialzuordnung_order_by!]

    # filter the rows returned
    where: materialzuordnung_bool_exp
  ): [materialzuordnung!]!
  modul: String!

  # An array relationship
  modulhierarchies(
    # distinct select on columns
    distinct_on: [modulhierarchie_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [modulhierarchie_order_by!]

    # filter the rows returned
    where: modulhierarchie_bool_exp
  ): [modulhierarchie!]!
}

# Boolean expression to filter rows from the table "module". All fields are combined with a logical 'AND'.
input module_bool_exp {
  _and: [module_bool_exp]
  _not: module_bool_exp
  _or: [module_bool_exp]
  lehrplanzuordnungs: lehrplanzuordnung_bool_exp
  materialzuordnungs: materialzuordnung_bool_exp
  modul: String_comparison_exp
  modulhierarchies: modulhierarchie_bool_exp
}

# ordering options when selecting data from "module"
input module_order_by {
  modul: order_by
}

# select columns of table "module"
enum module_select_column {
  # column name
  modul
}

# columns and relationships of "modulhierarchie"
type modulhierarchie {
  # An object relationship
  module: module!
  untermodul: String!
}

# Boolean expression to filter rows from the table "modulhierarchie". All fields are combined with a logical 'AND'.
input modulhierarchie_bool_exp {
  _and: [modulhierarchie_bool_exp]
  _not: modulhierarchie_bool_exp
  _or: [modulhierarchie_bool_exp]
  module: module_bool_exp
  untermodul: String_comparison_exp
}

# ordering options when selecting data from "modulhierarchie"
input modulhierarchie_order_by {
  module: module_order_by
  untermodul: order_by
}

# select columns of table "modulhierarchie"
enum modulhierarchie_select_column {
  # column name
  untermodul
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# query root
type query_root {
  # fetch data from the table: "lehrplan"
  lehrplan(
    # distinct select on columns
    distinct_on: [lehrplan_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplan_order_by!]

    # filter the rows returned
    where: lehrplan_bool_exp
  ): [lehrplan!]!

  # fetch data from the table: "lehrplandetails"
  lehrplandetails(
    # distinct select on columns
    distinct_on: [lehrplandetails_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplandetails_order_by!]

    # filter the rows returned
    where: lehrplandetails_bool_exp
  ): [lehrplandetails!]!

  # fetch data from the table: "lehrplandetails" using primary key columns
  lehrplandetails_by_pk(lehrplanid: Int!): lehrplandetails

  # fetch data from the table: "lehrplanzuordnung"
  lehrplanzuordnung(
    # distinct select on columns
    distinct_on: [lehrplanzuordnung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplanzuordnung_order_by!]

    # filter the rows returned
    where: lehrplanzuordnung_bool_exp
  ): [lehrplanzuordnung!]!

  # fetch data from the table: "lehrplanzuordnung" using primary key columns
  lehrplanzuordnung_by_pk(lehrplanid: Int!, modul: String!): lehrplanzuordnung

  # fetch data from the table: "material"
  material(
    # distinct select on columns
    distinct_on: [material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [material_order_by!]

    # filter the rows returned
    where: material_bool_exp
  ): [material!]!

  # fetch data from the table: "material" using primary key columns
  material_by_pk(link: String!): material

  # fetch data from the table: "materialzuordnung"
  materialzuordnung(
    # distinct select on columns
    distinct_on: [materialzuordnung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materialzuordnung_order_by!]

    # filter the rows returned
    where: materialzuordnung_bool_exp
  ): [materialzuordnung!]!

  # fetch data from the table: "materialzuordnung" using primary key columns
  materialzuordnung_by_pk(link: String!, modul: String!): materialzuordnung

  # fetch data from the table: "module"
  module(
    # distinct select on columns
    distinct_on: [module_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [module_order_by!]

    # filter the rows returned
    where: module_bool_exp
  ): [module!]!

  # fetch data from the table: "module" using primary key columns
  module_by_pk(modul: String!): module

  # fetch data from the table: "modulhierarchie"
  modulhierarchie(
    # distinct select on columns
    distinct_on: [modulhierarchie_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [modulhierarchie_order_by!]

    # filter the rows returned
    where: modulhierarchie_bool_exp
  ): [modulhierarchie!]!

  # fetch data from the table: "schulartenbedeutung"
  schulartenbedeutung(
    # distinct select on columns
    distinct_on: [schulartenbedeutung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [schulartenbedeutung_order_by!]

    # filter the rows returned
    where: schulartenbedeutung_bool_exp
  ): [schulartenbedeutung!]!

  # fetch data from the table: "schulartenbedeutung" using primary key columns
  schulartenbedeutung_by_pk(bundesland: bundesland!, schulart: String!): schulartenbedeutung
}

scalar ressourcenart

# expression to compare columns of type ressourcenart. All fields are combined with logical 'AND'.
input ressourcenart_comparison_exp {
  _eq: ressourcenart
  _gt: ressourcenart
  _gte: ressourcenart
  _in: [ressourcenart!]
  _is_null: Boolean
  _lt: ressourcenart
  _lte: ressourcenart
  _neq: ressourcenart
  _nin: [ressourcenart!]
}

# columns and relationships of "schulartenbedeutung"
type schulartenbedeutung {
  bundesland: bundesland!
  schulart: String!
  schulart_intern: String!
  sortcode: Int!
}

# Boolean expression to filter rows from the table "schulartenbedeutung". All fields are combined with a logical 'AND'.
input schulartenbedeutung_bool_exp {
  _and: [schulartenbedeutung_bool_exp]
  _not: schulartenbedeutung_bool_exp
  _or: [schulartenbedeutung_bool_exp]
  bundesland: bundesland_comparison_exp
  schulart: String_comparison_exp
  schulart_intern: String_comparison_exp
  sortcode: Int_comparison_exp
}

# ordering options when selecting data from "schulartenbedeutung"
input schulartenbedeutung_order_by {
  bundesland: order_by
  schulart: order_by
  schulart_intern: order_by
  sortcode: order_by
}

# select columns of table "schulartenbedeutung"
enum schulartenbedeutung_select_column {
  # column name
  bundesland

  # column name
  schulart

  # column name
  schulart_intern

  # column name
  sortcode
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "lehrplan"
  lehrplan(
    # distinct select on columns
    distinct_on: [lehrplan_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplan_order_by!]

    # filter the rows returned
    where: lehrplan_bool_exp
  ): [lehrplan!]!

  # fetch data from the table: "lehrplandetails"
  lehrplandetails(
    # distinct select on columns
    distinct_on: [lehrplandetails_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplandetails_order_by!]

    # filter the rows returned
    where: lehrplandetails_bool_exp
  ): [lehrplandetails!]!

  # fetch data from the table: "lehrplandetails" using primary key columns
  lehrplandetails_by_pk(lehrplanid: Int!): lehrplandetails

  # fetch data from the table: "lehrplanzuordnung"
  lehrplanzuordnung(
    # distinct select on columns
    distinct_on: [lehrplanzuordnung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lehrplanzuordnung_order_by!]

    # filter the rows returned
    where: lehrplanzuordnung_bool_exp
  ): [lehrplanzuordnung!]!

  # fetch data from the table: "lehrplanzuordnung" using primary key columns
  lehrplanzuordnung_by_pk(lehrplanid: Int!, modul: String!): lehrplanzuordnung

  # fetch data from the table: "material"
  material(
    # distinct select on columns
    distinct_on: [material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [material_order_by!]

    # filter the rows returned
    where: material_bool_exp
  ): [material!]!

  # fetch data from the table: "material" using primary key columns
  material_by_pk(link: String!): material

  # fetch data from the table: "materialzuordnung"
  materialzuordnung(
    # distinct select on columns
    distinct_on: [materialzuordnung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materialzuordnung_order_by!]

    # filter the rows returned
    where: materialzuordnung_bool_exp
  ): [materialzuordnung!]!

  # fetch data from the table: "materialzuordnung" using primary key columns
  materialzuordnung_by_pk(link: String!, modul: String!): materialzuordnung

  # fetch data from the table: "module"
  module(
    # distinct select on columns
    distinct_on: [module_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [module_order_by!]

    # filter the rows returned
    where: module_bool_exp
  ): [module!]!

  # fetch data from the table: "module" using primary key columns
  module_by_pk(modul: String!): module

  # fetch data from the table: "modulhierarchie"
  modulhierarchie(
    # distinct select on columns
    distinct_on: [modulhierarchie_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [modulhierarchie_order_by!]

    # filter the rows returned
    where: modulhierarchie_bool_exp
  ): [modulhierarchie!]!

  # fetch data from the table: "schulartenbedeutung"
  schulartenbedeutung(
    # distinct select on columns
    distinct_on: [schulartenbedeutung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [schulartenbedeutung_order_by!]

    # filter the rows returned
    where: schulartenbedeutung_bool_exp
  ): [schulartenbedeutung!]!

  # fetch data from the table: "schulartenbedeutung" using primary key columns
  schulartenbedeutung_by_pk(bundesland: bundesland!, schulart: String!): schulartenbedeutung
}

